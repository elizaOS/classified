import { describe, expect, it, vi, beforeEach, afterAll, beforeAll } from 'vitest';
import { experiencePlugin, ExperienceService } from '../src/index';
import { createMockRuntime, setupLoggerSpies, MockRuntime } from './test-utils';
import { HandlerCallback, IAgentRuntime, Memory, State, UUID, logger } from '@elizaos/core';
import { v4 as uuidv4 } from 'uuid';

/**
 * Integration tests for the Experience plugin demonstrate how multiple components 
 * work together: actions, providers, evaluators, and the experience service.
 */

// Set up spies on logger
beforeAll(() => {
  setupLoggerSpies();
});

afterAll(() => {
  vi.restoreAllMocks();
});

describe('Experience Plugin Integration', () => {
  let mockRuntime: MockRuntime;
  let experienceService: ExperienceService;

  beforeEach(async () => {
    // Create a mock runtime first
    mockRuntime = createMockRuntime({
      getService: vi.fn().mockImplementation((serviceType) => {
        if (serviceType === 'EXPERIENCE' || serviceType === 'experience') {
          return experienceService;
        }
        return null;
      }),
    });
    
    // Create the experience service using the static start method
    experienceService = await ExperienceService.start(mockRuntime as any);
  });

  describe('Plugin Structure', () => {
    it('should export all required components', () => {
      expect(experiencePlugin.services).toHaveLength(1);
      expect(experiencePlugin.actions).toHaveLength(3);
      expect(experiencePlugin.providers).toHaveLength(1);
      expect(experiencePlugin.evaluators).toHaveLength(1);
    });

    it('should have correct service type', () => {
      expect(ExperienceService.serviceType).toBe('EXPERIENCE');
    });

    it('should have all required providers', () => {
      const providerNames = experiencePlugin.providers?.map(p => p.name) || [];
      expect(providerNames).toContain('EXPERIENCE');
      expect(providerNames).toHaveLength(1);
    });

    it('should have experience evaluator', () => {
      const evaluator = experiencePlugin.evaluators?.find(e => e.name === 'EXPERIENCE_EVALUATOR');
      expect(evaluator).toBeDefined();
    });
  });

  describe('End-to-End Experience Flow', () => {
    it('should record, query, and analyze experiences', async () => {
      // Record an experience
      const experience = await experienceService.recordExperience({
        type: 'SUCCESS',
        outcome: 'POSITIVE',
        context: 'Testing experience recording',
        action: 'test_action',
        result: 'Test completed successfully',
        learning: 'Testing works correctly when done step by step',
        domain: 'testing',
        confidence: 0.9,
        importance: 0.8,
      });

      expect(experience.id).toBeDefined();
      expect(experience.learning).toBe('Testing works correctly when done step by step');

      // Query the experience
      const results = await experienceService.queryExperiences({
        query: 'testing',
        limit: 5,
        minConfidence: 0.8,
      });

      expect(results).toHaveLength(1);
      expect(results[0].id).toBe(experience.id);
    });

    it('should handle experience corrections and contradictions', async () => {
      // Record an initial experience
      await experienceService.recordExperience({
        type: 'LEARNING',
        outcome: 'NEUTRAL',
        context: 'Initial understanding',
        action: 'learn_concept',
        result: 'X works in way A',
        learning: 'X always works in way A',
        domain: 'concepts',
        confidence: 0.7,
        importance: 0.6,
      });

      // Record a correction
      await experienceService.recordExperience({
        type: 'CORRECTION',
        outcome: 'POSITIVE',
        context: 'Corrected understanding',
        action: 'correct_concept',
        result: 'X actually works in way B under certain conditions',
        learning: 'X works in way A normally, but way B under specific conditions',
        domain: 'concepts',
        confidence: 0.9,
        importance: 0.8,
      });

      const results = await experienceService.queryExperiences({
        query: 'X works',
        limit: 10,
        minConfidence: 0.0,
      });

      expect(results).toHaveLength(2);
    });

    it('should track access patterns and importance', async () => {
      const experience = await experienceService.recordExperience({
        type: 'DISCOVERY',
        outcome: 'POSITIVE',
        context: 'Found new capability',
        action: 'explore_system',
        result: 'System has hidden feature Y',
        learning: 'Feature Y can be accessed via method Z',
        domain: 'system',
        confidence: 0.8,
        importance: 0.9,
      });

      // Access the experience multiple times
      await experienceService.queryExperiences({
        query: 'feature Y',
        limit: 5,
        minConfidence: 0.0,
      });

      await experienceService.queryExperiences({
        query: 'method Z',
        limit: 5,
        minConfidence: 0.0,
      });

      // The experience should still exist and be accessible
      const results = await experienceService.queryExperiences({
        query: 'system capability',
        limit: 5,
        minConfidence: 0.0,
      });

      expect(results).toHaveLength(1);
      expect(results[0].id).toBe(experience.id);
    });
  });

  describe('Experience Evaluator Integration', () => {
    it('should validate agent messages correctly', async () => {
      const evaluator = experiencePlugin.evaluators!.find(e => e.name === 'EXPERIENCE_EVALUATOR')!;
      
      // Mock agent message that should trigger evaluation
      const agentMessage: Memory = {
        id: uuidv4() as UUID,
        entityId: mockRuntime.agentId,
        roomId: uuidv4() as UUID,
        content: { text: 'I successfully completed the task' },
        createdAt: Date.now(),
      };

      // Mock cache to simulate message count
      mockRuntime.setCache = vi.fn();
      mockRuntime.getCache = vi.fn().mockResolvedValue('10'); // Trigger evaluation

      const shouldRun = await evaluator.validate(mockRuntime as any, agentMessage);
      expect(shouldRun).toBe(true);
    });

    it('should detect and record discoveries using providers', async () => {
      const evaluator = experiencePlugin.evaluators!.find(e => e.name === 'EXPERIENCE_EVALUATOR')!;
      
      // Spy on the service's recordExperience method
      const recordSpy = vi.spyOn(experienceService, 'recordExperience');
      
      const agentMessage: Memory = {
        id: uuidv4() as UUID,
        entityId: mockRuntime.agentId,
        roomId: uuidv4() as UUID,
        content: { text: 'I discovered that the system has jq installed for JSON processing' },
        createdAt: Date.now(),
      };

      const state: State = {
        recentMessagesData: [
          { content: { text: 'Let me check what tools are available' } },
          { content: { text: 'I found that the system has jq installed' } },
          { content: { text: 'This is perfect for parsing JSON data' } },
        ],
      };

      // Mock the LLM response for experience extraction
      mockRuntime.useModel = vi.fn().mockResolvedValue(JSON.stringify([
        {
          type: 'DISCOVERY',
          learning: 'The system has jq tool available for JSON processing',
          context: 'System exploration revealed available tools',
          confidence: 0.9,
          reasoning: 'This is a useful discovery about system capabilities',
        },
      ]));

      await evaluator.handler(
        mockRuntime as any,
        agentMessage,
        state,
        {},
        undefined,
        []
      );

      // Should have recorded the experience
      expect(recordSpy).toHaveBeenCalled();
    });
  });

  describe('Provider Integration', () => {
    it('should provide relevant experiences via experience provider', async () => {
      // Record some experiences first
      await experienceService.recordExperience({
        type: 'SUCCESS',
        outcome: 'POSITIVE',
        context: 'API integration',
        action: 'connect_api',
        result: 'Successfully connected to external API',
        learning: 'API requires proper authentication headers',
        domain: 'network',
        confidence: 0.9,
        importance: 0.8,
      });

      const provider = experiencePlugin.providers!.find(p => p.name === 'EXPERIENCE')!;
      
      const message: Memory = {
        id: uuidv4() as UUID,
        entityId: uuidv4() as UUID,
        roomId: uuidv4() as UUID,
        content: { text: 'How do I connect to APIs?' },
        createdAt: Date.now(),
      };

      const result = await provider.get(mockRuntime as any, message, {});
      
      expect(result.text).toContain('experience');
      expect(result.data).toBeDefined();
    });
  });

  describe('Memory Management', () => {
    it('should handle large numbers of experiences efficiently', async () => {
      // Record multiple experiences
      for (let i = 0; i < 50; i++) {
        await experienceService.recordExperience({
          type: 'LEARNING',
          outcome: 'NEUTRAL',
          context: `Test scenario ${i}`,
          action: `test_action_${i}`,
          result: `Test result ${i}`,
          learning: `Learning point ${i}`,
          domain: 'testing',
          confidence: 0.7,
          importance: 0.5,
        });
      }

      const results = await experienceService.queryExperiences({
        query: 'test',
        limit: 10,
        minConfidence: 0.0,
      });

      expect(results).toHaveLength(10); // Should limit results properly
    });

    it('should handle embedding generation failures gracefully', async () => {
      // Mock embedding failure
      mockRuntime.embed = vi.fn().mockRejectedValue(new Error('Embedding failed'));

      // Should still record experience without embedding
      const experience = await experienceService.recordExperience({
        type: 'LEARNING',
        outcome: 'NEUTRAL',
        context: 'Test without embedding',
        action: 'test_action',
        result: 'Test result',
        learning: 'Test learning',
        domain: 'testing',
        confidence: 0.7,
        importance: 0.5,
      });

      expect(experience.id).toBeDefined();
    });
  });

  describe('Error Handling', () => {
    it('should handle service unavailability gracefully', async () => {
      const recordAction = experiencePlugin.actions!.find(a => a.name === 'RECORD_EXPERIENCE')!;
      
      // Mock runtime without service
      const runtimeWithoutService = createMockRuntime({
        getService: vi.fn().mockReturnValue(null),
      });

      const message: Memory = {
        id: uuidv4() as UUID,
        entityId: uuidv4() as UUID,
        roomId: uuidv4() as UUID,
        content: { text: 'Record this learning experience' },
        createdAt: Date.now(),
      };

      const result = await recordAction.handler(runtimeWithoutService as any, message);
      
      expect(result.success).toBe(true); // Should handle gracefully
      expect(result.text).toContain('understand');
    });

    it('should handle malformed queries gracefully', async () => {
      const queryAction = experiencePlugin.actions!.find(a => a.name === 'QUERY_EXPERIENCES')!;
      
      const message: Memory = {
        id: uuidv4() as UUID,
        entityId: uuidv4() as UUID,
        roomId: uuidv4() as UUID,
        content: { text: '' }, // Empty query
        createdAt: Date.now(),
      };

      const result = await queryAction.handler(mockRuntime as any, message);
      
      expect(result.success).toBe(true);
    });

    it('should handle concurrent access safely', async () => {
      // Create multiple concurrent operations
      const promises = [];
      
      for (let i = 0; i < 10; i++) {
        promises.push(
          experienceService.recordExperience({
            type: 'LEARNING',
            outcome: 'NEUTRAL',
            context: `Concurrent test ${i}`,
            action: `concurrent_action_${i}`,
            result: `Concurrent result ${i}`,
            learning: `Concurrent learning ${i}`,
            domain: 'concurrency',
            confidence: 0.7,
            importance: 0.5,
          })
        );
      }

      const experiences = await Promise.all(promises);
      
      expect(experiences).toHaveLength(10);
      experiences.forEach((exp, index) => {
        expect(exp.id).toBeDefined();
        expect(exp.learning).toContain(`Concurrent learning ${index}`);
      });
    });
  });
});