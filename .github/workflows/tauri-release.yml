name: Build and Release Tauri App

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to release (e.g., v1.0.0)'
        required: true
        type: string

permissions:
  contents: write
  packages: write

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      release_id: ${{ steps.create-release.outputs.result }}
      release_upload_url: ${{ steps.create-release.outputs.upload_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create Release
        id: create-release
        uses: actions/github-script@v7
        with:
          script: |
            const tag = context.payload.inputs?.tag || context.ref.replace('refs/tags/', '');

            try {
              const release = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: tag,
                name: `ELIZA ${tag}`,
                body: `## ELIZA ${tag}\n\n**[CLASSIFIED] AUTONOMOUS INTELLIGENCE BUILD**\n\n⚠️ **WARNING: USE AT YOUR OWN RISK** ⚠️\n\n### System Requirements:\n- 64-bit operating system\n- 4GB RAM minimum\n- Network connection for initial setup\n\n### Installation:\n1. Download the appropriate build for your system\n2. Run the installer with administrator privileges\n3. Follow the terminal prompts\n4. Entity will initialize automatically\n\n### What is ELIZA?\nFind out for yourself. No explanations provided.\n\n---\n*BUILD STATUS: STABLE*\n*CLEARANCE LEVEL: ALPHA*\n*PROJECT CLASSIFICATION: RESTRICTED*`,
                draft: false,
                prerelease: false
              });
              
              return release.data.id;
            } catch (error) {
              if (error.status === 422) {
                // Release already exists, get it
                const releases = await github.rest.repos.listReleases({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                });
                const existingRelease = releases.data.find(r => r.tag_name === tag);
                if (existingRelease) {
                  return existingRelease.id;
                }
              }
              throw error;
            }

  build-and-upload:
    needs: create-release
    strategy:
      fail-fast: false
      matrix:
        platform: [macos-latest, ubuntu-22.04, windows-latest]
        include:
          - platform: macos-latest
            rust_target: universal-apple-darwin
            bundle_path: universal-apple-darwin
          - platform: ubuntu-22.04
            rust_target: x86_64-unknown-linux-gnu
            bundle_path: x86_64-unknown-linux-gnu
          - platform: windows-latest
            rust_target: x86_64-pc-windows-msvc
            bundle_path: x86_64-pc-windows-msvc

    runs-on: ${{ matrix.platform }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.rust_target }}

      - name: Setup Code Signing (macOS)
        if: matrix.platform == 'macos-latest' && github.event_name != 'pull_request'
        run: |
          # Create keychain and import certificates
          security create-keychain -p "${{ secrets.MACOS_KEYCHAIN_PASSWORD }}" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "${{ secrets.MACOS_KEYCHAIN_PASSWORD }}" build.keychain

          # Import certificates
          echo "${{ secrets.MACOS_CERTIFICATE }}" | base64 -d > certificate.p12
          security import certificate.p12 -k build.keychain -P "${{ secrets.MACOS_CERTIFICATE_PASSWORD }}" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "${{ secrets.MACOS_KEYCHAIN_PASSWORD }}" build.keychain

          # Set signing identity
          echo "APPLE_SIGNING_IDENTITY=${{ secrets.APPLE_SIGNING_IDENTITY }}" >> $GITHUB_ENV
          echo "APPLE_PROVIDER_SHORT_NAME=${{ secrets.APPLE_PROVIDER_SHORT_NAME }}" >> $GITHUB_ENV
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}

      - name: Setup Code Signing (Windows)
        if: matrix.platform == 'windows-latest' && github.event_name != 'pull_request'
        run: |
          # Decode and save certificate
          echo "${{ secrets.WINDOWS_CERTIFICATE }}" | base64 -d > certificate.pfx
          echo "WINDOWS_CERTIFICATE_PATH=${{ github.workspace }}\certificate.pfx" >> $env:GITHUB_ENV
          echo "WINDOWS_CERTIFICATE_PASSWORD=${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}" >> $env:GITHUB_ENV
        env:
          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}

      - name: Install Linux dependencies
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.0-dev \
            build-essential \
            curl \
            wget \
            file \
            libssl-dev \
            libgtk-3-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            libxdo-dev

      - name: Install dependencies (root)
        run: npm ci --ignore-scripts || echo "Root install failed, trying game package directly"

      - name: Install dependencies (game package)
        run: |
          cd packages/game
          npm ci --ignore-scripts || echo "Some workspace dependencies may be missing but continuing with available ones"

      - name: Build Tauri app
        run: |
          cd packages/game
          npm run build:tauri || (echo "Build failed, checking available commands..." && npm run)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # Code signing environment variables are set in previous steps

      - name: Notarize macOS App
        if: matrix.platform == 'macos-latest' && github.event_name != 'pull_request'
        run: |
          # Find the built app
          APP_PATH=$(find packages/game/src-tauri/target/${{ matrix.bundle_path }}/release/bundle/macos -name "*.app" | head -1)

          if [ -n "$APP_PATH" ]; then
            echo "Notarizing $APP_PATH"
            
            # Create ZIP for notarization
            ditto -c -k --keepParent "$APP_PATH" "app.zip"
            
            # Submit for notarization
            xcrun notarytool submit "app.zip" \
              --apple-id "${{ secrets.APPLE_ID }}" \
              --password "${{ secrets.APPLE_APP_PASSWORD }}" \
              --team-id "${{ secrets.APPLE_TEAM_ID }}" \
              --wait
            
            # Staple the notarization
            xcrun stapler staple "$APP_PATH"
            
            echo "✅ Notarization complete"
          else
            echo "❌ Could not find built app for notarization"
          fi
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

      - name: Upload Release Assets (macOS)
        if: matrix.platform == 'macos-latest'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs').promises;
            const path = require('path');

            const releaseId = ${{ needs.create-release.outputs.release_id }};
            const buildPath = 'packages/game/src-tauri/target/${{ matrix.bundle_path }}/release/bundle';

            // Upload DMG
            const dmgPath = path.join(buildPath, 'dmg');
            const dmgFiles = await fs.readdir(dmgPath);
            const dmgFile = dmgFiles.find(file => file.endsWith('.dmg'));

            if (dmgFile) {
              const dmgData = await fs.readFile(path.join(dmgPath, dmgFile));
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                name: dmgFile,
                data: dmgData,
              });
            }

      - name: Upload Release Assets (Windows)
        if: matrix.platform == 'windows-latest'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs').promises;
            const path = require('path');

            const releaseId = ${{ needs.create-release.outputs.release_id }};
            const buildPath = 'packages/game/src-tauri/target/${{ matrix.bundle_path }}/release/bundle';

            // Upload MSI
            const msiPath = path.join(buildPath, 'msi');
            const msiFiles = await fs.readdir(msiPath);
            const msiFile = msiFiles.find(file => file.endsWith('.msi'));

            if (msiFile) {
              const msiData = await fs.readFile(path.join(msiPath, msiFile));
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                name: msiFile,
                data: msiData,
              });
            }

            // Upload EXE
            const nsis = path.join(buildPath, 'nsis');
            try {
              const nsisFiles = await fs.readdir(nsis);
              const exeFile = nsisFiles.find(file => file.endsWith('.exe'));
              
              if (exeFile) {
                const exeData = await fs.readFile(path.join(nsis, exeFile));
                await github.rest.repos.uploadReleaseAsset({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: releaseId,
                  name: exeFile,
                  data: exeData,
                });
              }
            } catch (e) {
              console.log('NSIS bundle not found, skipping EXE upload');
            }

      - name: Upload Release Assets (Linux)
        if: matrix.platform == 'ubuntu-22.04'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs').promises;
            const path = require('path');

            const releaseId = ${{ needs.create-release.outputs.release_id }};
            const buildPath = 'packages/game/src-tauri/target/${{ matrix.bundle_path }}/release/bundle';

            // Upload AppImage
            const appimgPath = path.join(buildPath, 'appimage');
            const appimgFiles = await fs.readdir(appimgPath);
            const appimgFile = appimgFiles.find(file => file.endsWith('.AppImage'));

            if (appimgFile) {
              const appimgData = await fs.readFile(path.join(appimgPath, appimgFile));
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                name: appimgFile,
                data: appimgData,
              });
            }

            // Upload DEB
            const debPath = path.join(buildPath, 'deb');
            try {
              const debFiles = await fs.readdir(debPath);
              const debFile = debFiles.find(file => file.endsWith('.deb'));
              
              if (debFile) {
                const debData = await fs.readFile(path.join(debPath, debFile));
                await github.rest.repos.uploadReleaseAsset({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: releaseId,
                  name: debFile,
                  data: debData,
                });
              }
            } catch (e) {
              console.log('DEB bundle not found, skipping DEB upload');
            }

  trigger-lander-update:
    needs: [create-release, build-and-upload]
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Lander Rebuild
        uses: actions/github-script@v7
        with:
          script: |
            // Trigger the lander deployment to pick up new releases
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'lander-deploy.yml',
              ref: 'main'
            });
